'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var curry = require('@blakek/curry');
var pathington = require('pathington');

function isObject(object) {
  if (object === null) return false;
  const type = typeof object;
  return type === 'object' || type === 'function';
}

const NotFound = Symbol('curriable placeholder');
function clone(value) {
  if (value instanceof Date) {
    return new Date(value.getTime());
  }

  if (value instanceof Map) {
    const result = new Map();
    value.forEach((value, key) => {
      result.set(key, clone(value));
    });
    return result;
  }

  if (value instanceof RegExp) {
    return new RegExp(value.source, value.flags);
  }

  if (value instanceof Set) {
    const result = new Set();
    value.forEach(x => {
      result.add(clone(x));
    });
    return result;
  }

  if (typeof value === 'object') {
    if (value === null) {
      return null;
    }

    const result = Array.isArray(value) ? [] : {};

    for (const key in value) {
      result[key] = clone(value[key]);
    }

    return result;
  }

  return value;
}
function traverseObject(object, path) {
  // If the path has been exhausted, return the current object
  if (path.length === 0) {
    return object;
  } // If the value could not be found, return `defaultValue`


  if (!isObject(object)) {
    return NotFound;
  }

  const [key, ...keys] = path; // Search deeper in the object

  if (key in object) {
    return traverseObject(object[key], keys);
  } // The key was not found in the object.


  return NotFound;
}

function _getOr(defaultValue, path, object) {
  if (path === undefined) return object;
  const value = traverseObject(object, pathington.parse(path));

  if (value === NotFound || value === undefined) {
    return defaultValue;
  }

  return value;
}

const _get = (path, object) => _getOr(undefined, path, object);

function _has(path, object) {
  const value = traverseObject(object, pathington.parse(path));
  return value !== NotFound;
}

function _remove(path, object) {
  if (path === undefined) return object;
  const parsedPath = pathington.parse(path);
  const referencePath = parsedPath.slice(0, -1);
  const finalPath = parsedPath[parsedPath.length - 1];
  const reference = traverseObject(object, pathington.parse(referencePath));
  if (!reference) return object;
  delete reference[finalPath];
  return object;
}

function _omit(properties, object) {
  const cloned = clone(object);
  properties.forEach(property => remove(property, cloned));
  return cloned;
}

function _pluck(properties, object) {
  return properties.reduce((subset, property) => _set(_get(property, object), property, subset), {});
}

function _set(value, path, object) {
  const parsedPath = pathington.parse(path);
  let reference = object;
  parsedPath.forEach((key, index) => {
    if (index === parsedPath.length - 1) {
      reference[key] = value;
      return;
    }

    if (!isObject(reference[key])) {
      reference[key] = {};
    }

    reference = reference[key];
  });
  return object;
}

const get = curry.curry(_get);
const getOr = curry.curry(_getOr);
const has = curry.curry(_has);
const omit = curry.curry(_omit);
const pluck = curry.curry(_pluck);
const remove = curry.curry(_remove);
const set = curry.curry(_set);

exports.clone = clone;
exports.get = get;
exports.getOr = getOr;
exports.has = has;
exports.omit = omit;
exports.pluck = pluck;
exports.remove = remove;
exports.set = set;
exports.traverseObject = traverseObject;
