{"version":3,"file":"index.umd.js","sources":["../node_modules/@blakek/curry/dist/curry.esm.js","../node_modules/pathington/es/constants.js","../node_modules/pathington/es/utils.js","../node_modules/pathington/es/index.js","../src/is-object.ts","../src/index.ts"],"sourcesContent":["function curry(fn, arity = fn.length) {\n  return function curried(...args) {\n    if (args.length >= arity) {\n      return fn(...args.slice(0, arity));\n    }\n\n    return (...newArgs) => curried(...args, ...newArgs);\n  };\n}\nfunction curryRight(fn, arity = fn.length) {\n  return function curried(...args) {\n    if (args.length >= arity) {\n      return fn(...args.slice(0, arity).reverse());\n    }\n\n    return (...newArgs) => curried(...args, ...newArgs);\n  };\n}\n\nexport { curry, curryRight };\n","/**\n * @constant {Object} CACHE\n *\n * @property {function} clear clear the cache results\n * @property {Object} results the map of path => array results\n * @property {number} size the size of the cache\n */\nexport var CACHE = {\n  clear: function clear() {\n    CACHE.results = {};\n    CACHE.size = 0;\n  },\n  results: {},\n  size: 0\n};\n/**\n * @constant {RegExp} DOTTY_WITH_BRACKETS_SYNTAX\n */\n\nexport var DOTTY_WITH_BRACKETS_SYNTAX = /\"[^\"]+\"|`[^`]+`|'[^']+'|[^.[\\]]+/g;\n/**\n * @constant {number} MAX_CACHE_SIZE\n */\n\nexport var MAX_CACHE_SIZE = 500;\n/**\n * @constant {RegExp} NUMBER\n */\n\nexport var NUMBER = /^\\d+$/i;\n/**\n * @constant {RegExp} QUOTED_KEY\n */\n\nexport var QUOTED_KEY = /^\"[^\"]+\"|`[^`]+`|'[^']+'$/;\n/**\n * @constant {Array<string>} VALID_QUOTES\n */\n\nexport var VALID_QUOTES = /^[\"'`]{1}$/;\n/**\n * @constant {RegExp} VALID_KEY\n */\n\nexport var VALID_KEY = /^\\d+$|^[a-zA-Z_$][\\w$]+$/;\n/**\n * @constant {RegExp} WHITE_SPACE\n */\n\nexport var WHITE_SPACE = /\\s/;","// constants\nimport { CACHE, DOTTY_WITH_BRACKETS_SYNTAX, MAX_CACHE_SIZE, NUMBER, QUOTED_KEY, VALID_KEY, WHITE_SPACE } from './constants';\n/**\n * @function isNumericKey\n *\n * @description\n * is the key passed a numeric string\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key passed a numeric string\n */\n\nexport var isNumericKey = function isNumericKey(key) {\n  return !!(key && key.length) && NUMBER.test(key);\n};\n/**\n * @function isQuotedKey\n *\n * @description\n * is the key passed a quoted key\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key a quoted key\n */\n\nexport var isQuotedKey = function isQuotedKey(key) {\n  return QUOTED_KEY.test(key);\n};\n/**\n * @function map\n *\n * @description\n * map the array to a new array based on fn\n *\n * @param {Array<*>} array the array to map\n * @param {function} fn the function to call with each iteration value\n * @returns {Array<*>} the mapped array\n */\n\nexport var map = function map(array, fn) {\n  var length = array.length;\n  var mapped = [];\n\n  for (var index = 0; index < length; index++) {\n    mapped[index] = fn(array[index]);\n  }\n\n  return mapped;\n};\n/**\n * @function shouldBeInBrackets\n *\n * @description\n * should the key passed be encased in brackets when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in brackets\n */\n\nexport var shouldBeInBrackets = function shouldBeInBrackets(key) {\n  return typeof key === 'number' || isNumericKey(key) || isQuotedKey(key);\n};\n/**\n * @function shouldBeInQuotes\n *\n * @description\n * should the key passed be encased in quotes when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in quotes\n */\n\nexport var shouldBeInQuotes = function shouldBeInQuotes(key) {\n  return WHITE_SPACE.test(key) || !VALID_KEY.test(key);\n};\n/**\n * @function createGetNormalizedCreateKey\n *\n * @description\n * get the normalized path string based on the quote and key passed\n *\n * @param {string} [quote=\"] the quote string to use\n * @returns {function(string, *): string}\n */\n\nexport var createGetNormalizedCreateKey = function createGetNormalizedCreateKey(quote) {\n  return function (existingString, key) {\n    var normalizedKey = shouldBeInQuotes(key) ? \"\" + quote + key + quote : key;\n    return existingString + (shouldBeInBrackets(normalizedKey) ? \"[\" + normalizedKey + \"]\" : \".\" + normalizedKey);\n  };\n};\n/**\n * @function getNormalizedParseKey\n *\n * @description\n * get the key as a number if parseable, or as a quoted string if applicable\n *\n * @param {string} key the key to try to parse\n * @returns {number|string} the parsed key\n */\n\nexport var getNormalizedParseKey = function getNormalizedParseKey(key) {\n  var cleanKey = isQuotedKey(key) ? key.slice(1, key.length - 1) : key;\n  return isNumericKey(cleanKey) ? +cleanKey : cleanKey;\n};\n/**\n * @function parsePath\n *\n * @description\n * parse the path, memoizing the results\n *\n * @param {string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parseStringPath = function parseStringPath(path) {\n  if (CACHE.results[path]) {\n    return CACHE.results[path];\n  }\n\n  if (CACHE.size > MAX_CACHE_SIZE) {\n    CACHE.clear();\n  }\n\n  CACHE.results[path] = path ? map(path.match(DOTTY_WITH_BRACKETS_SYNTAX), getNormalizedParseKey) : [path];\n  CACHE.size++;\n  return CACHE.results[path];\n};","// constants\nimport { VALID_QUOTES } from './constants'; // utils\n\nimport { createGetNormalizedCreateKey, getNormalizedParseKey, map, parseStringPath } from './utils';\nvar isArray = Array.isArray;\n/**\n * @function create\n *\n * @description\n * create a new path string based on the path and quote passed\n *\n * @param {Array<number|string>} path the path to convert to a string\n * @param {string} [quote=\"] the quote string to use when quoting keys\n * @returns {string} the path string\n */\n\nexport var create = function create(path, quote) {\n  if (quote === void 0) {\n    quote = '\"';\n  }\n\n  if (!isArray(path)) {\n    throw new ReferenceError('path passed must be an array');\n  }\n\n  if (!VALID_QUOTES.test(quote)) {\n    throw new SyntaxError(\"quote \" + quote + \" passed is invalid, must be \\\", `, or '.\");\n  }\n\n  var pathString = path.reduce(createGetNormalizedCreateKey(quote), '');\n  return pathString[0] === '.' ? pathString.slice(1) : pathString;\n};\n/**\n * @function parse\n *\n * @description\n * the path parsed into a valid array of keys / indices\n *\n * @param {Array<number|string>|number|string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parse = function parse(path) {\n  if (typeof path === 'string') {\n    return parseStringPath(path);\n  }\n\n  if (isArray(path)) {\n    return map(path, getNormalizedParseKey);\n  }\n\n  var normalizedParseKey = getNormalizedParseKey(path);\n  return [typeof normalizedParseKey === 'number' ? normalizedParseKey : \"\" + normalizedParseKey];\n};","export function isObject(object: any): boolean {\n  if (object === null) return false;\n\n  const type = typeof object;\n  return type === 'object' || type === 'function';\n}\n","import { curry } from '@blakek/curry';\nimport { parse } from 'pathington';\nimport { isObject } from './is-object';\n\nexport type Path = Array<number | string> | string;\nexport type ObjectLike = Record<keyof unknown, unknown>;\nexport type WithProperties = ObjectLike | unknown[];\n\nconst NotFound = Symbol('curriable placeholder');\n\nexport function clone<T extends unknown>(value: T): T {\n  if (value instanceof Date) {\n    return new Date((value as Date).getTime()) as T;\n  }\n\n  if (value instanceof Map) {\n    const result = new Map();\n\n    value.forEach((value, key) => {\n      result.set(key, clone(value));\n    });\n\n    return result as T;\n  }\n\n  if (value instanceof RegExp) {\n    return new RegExp(value.source, value.flags) as T;\n  }\n\n  if (value instanceof Set) {\n    const result = new Set();\n\n    value.forEach(x => {\n      result.add(clone(x));\n    });\n\n    return result as T;\n  }\n\n  if (typeof value === 'object') {\n    if (value === null) {\n      return null;\n    }\n\n    const result = (Array.isArray(value) ? [] : {}) as T;\n\n    for (const key in value) {\n      result[key] = clone(value[key]);\n    }\n\n    return result;\n  }\n\n  return value;\n}\n\nexport function traverseObject(object: any, path: string[]): any {\n  // If the path has been exhausted, return the current object\n  if (path.length === 0) {\n    return object;\n  }\n\n  // If the value could not be found, return `defaultValue`\n  if (!isObject(object)) {\n    return NotFound;\n  }\n\n  const [key, ...keys] = path;\n\n  // Search deeper in the object\n  if (key in object) {\n    return traverseObject(object[key], keys);\n  }\n\n  // The key was not found in the object.\n  return NotFound;\n}\n\nfunction _getOr(defaultValue: any, path: Path, object: any): any {\n  if (path === undefined) return object;\n\n  const value = traverseObject(object, parse(path));\n\n  if (value === NotFound || value === undefined) {\n    return defaultValue;\n  }\n\n  return value;\n}\n\nconst _get = (path: Path, object: any): any => _getOr(undefined, path, object);\n\nfunction _has(path: Path, object: any): boolean {\n  const value = traverseObject(object, parse(path));\n  return value !== NotFound;\n}\n\nfunction _remove(path: Path, object: any): any {\n  if (path === undefined) return object;\n  const parsedPath = parse(path);\n\n  const referencePath = parsedPath.slice(0, -1);\n  const finalPath = parsedPath[parsedPath.length - 1];\n  const reference = traverseObject(object, parse(referencePath));\n\n  if (!reference) return object;\n\n  delete reference[finalPath];\n\n  return object;\n}\n\nfunction _omit(properties: Path[], object: WithProperties): WithProperties {\n  const cloned = clone(object);\n  properties.forEach(property => remove(property, cloned));\n  return cloned;\n}\n\nfunction _pluck(properties: Path[], object: any): any {\n  return properties.reduce(\n    (subset, property) => _set(_get(property, object), property, subset),\n    {}\n  );\n}\n\nfunction _set(value: any, path: Path, object: any): any {\n  const parsedPath = parse(path);\n  let reference = object;\n\n  parsedPath.forEach((key, index) => {\n    if (index === parsedPath.length - 1) {\n      reference[key] = value;\n      return;\n    }\n\n    if (!isObject(reference[key])) {\n      reference[key] = {};\n    }\n\n    reference = reference[key];\n  });\n\n  return object;\n}\n\nexport const get = curry(_get);\nexport const getOr = curry(_getOr);\nexport const has = curry(_has);\nexport const omit = curry(_omit);\nexport const pluck = curry(_pluck);\nexport const remove = curry(_remove);\nexport const set = curry(_set);\n"],"names":["curry","fn","arity","length","curried","args","slice","newArgs","CACHE","clear","results","size","DOTTY_WITH_BRACKETS_SYNTAX","NUMBER","QUOTED_KEY","map","array","mapped","index","getNormalizedParseKey","key","cleanKey","test","isQuotedKey","isNumericKey","isArray","Array","parse","path","match","parseStringPath","normalizedParseKey","isObject","object","type","NotFound","Symbol","clone","value","Date","getTime","Map","result","forEach","set","RegExp","source","flags","Set","x","add","traverseObject","keys","_getOr","defaultValue","undefined","_get","_set","parsedPath","reference","get","getOr","has","omit","properties","cloned","property","remove","pluck","reduce","subset","referencePath","finalPath"],"mappings":"4OAAA,SAASA,EAAMC,EAAIC,mBAAAA,IAAAA,EAAQD,EAAGE,QACrB,SAASC,+BAAWC,2BAAAA,yBACrBA,EAAKF,QAAUD,EACVD,eAAMI,EAAKC,MAAM,EAAGJ,IAGtB,sCAAIK,2BAAAA,yBAAYH,eAAWC,SAASE,MCCxC,IAAIC,EAAQ,CACjBC,MAAO,WACLD,EAAME,QAAU,GAChBF,EAAMG,KAAO,GAEfD,QAAS,GACTC,KAAM,GAMGC,EAA6B,oCAU7BC,EAAS,SAKTC,EAAa,4BCKbC,EAAM,SAAaC,EAAOf,WAC/BE,EAASa,EAAMb,OACfc,EAAS,GAEJC,EAAQ,EAAGA,EAAQf,EAAQe,IAClCD,EAAOC,GAASjB,EAAGe,EAAME,WAGpBD,GAsDEE,EAAwB,SAA+BC,OAC5DC,EA7EmB,SAAqBD,UACrCN,EAAWQ,KAAKF,GA4ERG,CAAYH,GAAOA,EAAId,MAAM,EAAGc,EAAIjB,OAAS,GAAKiB,SA1FzC,SAAsBA,YACpCA,IAAOA,EAAIjB,SAAWU,EAAOS,KAAKF,GA0FrCI,CAAaH,IAAaA,EAAWA,GCnG1CI,EAAUC,MAAMD,QAsCTE,EAAQ,SAAeC,MACZ,iBAATA,SDwEgB,SAAyBA,UAChDpB,EAAME,QAAQkB,KAIdpB,EAAMG,KDhGgB,KCiGxBH,EAAMC,QAGRD,EAAME,QAAQkB,GAAQA,EAAOb,EAAIa,EAAKC,MAAMjB,GAA6BO,GAAyB,CAACS,GACnGpB,EAAMG,QARGH,EAAME,QAAQkB,GCzEdE,CAAgBF,MAGrBH,EAAQG,UACHb,EAAIa,EAAMT,OAGfY,EAAqBZ,EAAsBS,SACxC,CAA+B,iBAAvBG,EAAkCA,EAAqB,GAAKA,ICpDtE,SAASC,EAASC,MACR,OAAXA,EAAiB,OAAO,MAEtBC,SAAcD,QACJ,WAATC,GAA8B,aAATA,ECI9B,IAAMC,EAAWC,OAAO,yBAEjB,SAASC,EAAyBC,MACnCA,aAAiBC,YACZ,IAAIA,KAAMD,EAAeE,cAG9BF,aAAiBG,IAAK,KAClBC,EAAS,IAAID,WAEnBH,EAAMK,SAAQ,SAACL,EAAOlB,GACpBsB,EAAOE,IAAIxB,EAAKiB,EAAMC,OAGjBI,KAGLJ,aAAiBO,cACZ,IAAIA,OAAOP,EAAMQ,OAAQR,EAAMS,UAGpCT,aAAiBU,IAAK,KAClBN,EAAS,IAAIM,WAEnBV,EAAMK,SAAQ,SAAAM,GACZP,EAAOQ,IAAIb,EAAMY,OAGZP,KAGY,iBAAVJ,EAAoB,IACf,OAAVA,SACK,SAGHI,EAAUhB,MAAMD,QAAQa,GAAS,GAAK,OAEvC,IAAMlB,KAAOkB,EAChBI,EAAOtB,GAAOiB,EAAMC,EAAMlB,WAGrBsB,SAGFJ,EAGF,SAASa,EAAelB,EAAaL,MAEtB,IAAhBA,EAAKzB,cACA8B,MAIJD,EAASC,UACLE,MAGFf,EAAgBQ,KAARwB,EAAQxB,kBAGnBR,KAAOa,EACFkB,EAAelB,EAAOb,GAAMgC,GAI9BjB,EAGT,SAASkB,EAAOC,EAAmB1B,EAAYK,WAChCsB,IAAT3B,EAAoB,OAAOK,MAEzBK,EAAQa,EAAelB,EAAQN,EAAMC,WAEvCU,IAAUH,QAAsBoB,IAAVjB,EACjBgB,EAGFhB,EAGT,IAAMkB,EAAO,SAAC5B,EAAYK,UAAqBoB,OAAOE,EAAW3B,EAAMK,IAmCvE,SAASwB,EAAKnB,EAAYV,EAAYK,OAC9ByB,EAAa/B,EAAMC,GACrB+B,EAAY1B,SAEhByB,EAAWf,SAAQ,SAACvB,EAAKF,GACnBA,IAAUwC,EAAWvD,OAAS,GAK7B6B,EAAS2B,EAAUvC,MACtBuC,EAAUvC,GAAO,IAGnBuC,EAAYA,EAAUvC,IARpBuC,EAAUvC,GAAOkB,KAWdL,MAGI2B,EAAM5D,EAAMwD,GACZK,EAAQ7D,EAAMqD,GACdS,EAAM9D,GAvDnB,SAAc4B,EAAYK,UACVkB,EAAelB,EAAQN,EAAMC,MAC1BO,KAsDN4B,EAAO/D,GApCpB,SAAegE,EAAoB/B,OAC3BgC,EAAS5B,EAAMJ,UACrB+B,EAAWrB,SAAQ,SAAAuB,UAAYC,EAAOD,EAAUD,MACzCA,KAkCIG,EAAQpE,GA/BrB,SAAgBgE,EAAoB/B,UAC3B+B,EAAWK,QAChB,SAACC,EAAQJ,UAAaT,EAAKD,EAAKU,EAAUjC,GAASiC,EAAUI,KAC7D,OA6BSH,EAASnE,GArDtB,SAAiB4B,EAAYK,WACdsB,IAAT3B,EAAoB,OAAOK,MACzByB,EAAa/B,EAAMC,GAEnB2C,EAAgBb,EAAWpD,MAAM,GAAI,GACrCkE,EAAYd,EAAWA,EAAWvD,OAAS,GAC3CwD,EAAYR,EAAelB,EAAQN,EAAM4C,WAE1CZ,UAEEA,EAAUa,GAEVvC,GAJgBA,KA8CZW,EAAM5C,EAAMyD"}